/*
Ply.inl
*/

#pragma once

#include <typeinfo>

namespace jl
{
	template<typename T> struct Vert3 { T x, y, z; };

	template<typename T>
	void WritePoint3ToPlyFile(const std::vector<Point<T, 3>>& points, const std::string& filename)
	{
		std::vector<Vert3<T>> vertices(points.size());
		std::transform(points.begin(), points.end(), vertices.begin(),
			[](Point<T, 3> p) -> Vert3<T> { return { p[0],p[1],p[2] }; });

		std::filebuf fb_binary;
		fb_binary.open(filename + "-binary.ply", std::ios::out | std::ios::binary);
		std::ostream outstream_binary(&fb_binary);
		if (outstream_binary.fail()) throw std::runtime_error("failed to open " + filename);

		PlyFile points_file;

		Type outputType;
		if (typeid(T) == typeid(float)) outputType = Type::FLOAT32;
		else							outputType = Type::FLOAT64;

		points_file.add_properties_to_element("vertex", { "x", "y", "z" },
			outputType, points.size(), reinterpret_cast<uint8_t*>(vertices.data()), Type::INVALID, 0);

		points_file.get_comments().push_back("generated by tinyply 2.3");

		// Write a binary file
		points_file.write(outstream_binary, true);
	}
}